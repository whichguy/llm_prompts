name: AgentWatch Orchestrator
on:
  issue_comment:
    types: [created]
  pull_request:
    types: [opened, synchronize]

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: read

jobs:
  process-command:
    if: github.event_name == 'issue_comment' && contains(github.event.comment.body, '@agent-')
    runs-on: ubuntu-latest
    outputs:
      command: ${{ steps.parse.outputs.command }}
      agent: ${{ steps.parse.outputs.agent }}
      pattern: ${{ steps.parse.outputs.pattern }}
    steps:
      - uses: actions/checkout@v4
      - name: Parse Command
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const comment = context.payload.comment.body;
            const match = comment.match(/@agent-(watch|unwatch|list)\s*(\S+)?\s*(.*)?/);
            if (match) {
              core.setOutput('command', match[1]);
              core.setOutput('agent', match[2] || '');
              core.setOutput('pattern', match[3] || '');
            }

  handle-command:
    needs: process-command
    if: needs.process-command.outputs.command
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      - name: Handle Command
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs').promises;
            const path = require('path');
            const yaml = require('js-yaml');
            
            const command = '${{ needs.process-command.outputs.command }}';
            const agent = '${{ needs.process-command.outputs.agent }}';
            const pattern = '${{ needs.process-command.outputs.pattern }}';
            const user = context.payload.comment.user.login;
            const prNumber = context.payload.issue.number;
            
            const configPath = '.github/agentwatch.yml';
            let config = { watchers: [] };
            
            try {
              const content = await fs.readFile(configPath, 'utf8');
              config = yaml.load(content) || { watchers: [] };
            } catch (e) {
              // File doesn't exist, use default
            }
            
            let message = '';
            
            if (command === 'watch') {
              const exists = config.watchers.some(w => 
                w.agent === agent && w.pattern === pattern
              );
              
              if (!exists) {
                config.watchers.push({
                  name: `${agent} for ${pattern}`,
                  agent: agent,
                  pattern: pattern,
                  exclude: [],
                  added_by: user,
                  added_at: new Date().toISOString(),
                  pr_number: prNumber
                });
                message = `✅ Watcher added:\n- Agent: ${agent}\n- Pattern: ${pattern}\n- Excludes: []`;
              } else {
                message = `⚠️ Watcher already exists for ${agent} on ${pattern}`;
              }
            } else if (command === 'unwatch') {
              const index = config.watchers.findIndex(w => 
                w.agent === agent && w.pattern === pattern
              );
              
              if (index !== -1) {
                config.watchers.splice(index, 1);
                message = `✅ Watcher removed:\n- Agent: ${agent}\n- Pattern: ${pattern}`;
              } else {
                message = `⚠️ No watcher found for ${agent} on ${pattern}`;
              }
            } else if (command === 'list') {
              if (config.watchers.length > 0) {
                message = '📋 Active watchers:\n' + config.watchers.map((w, i) => 
                  `${i+1}. **${w.agent}** watching \`${w.pattern}\` (added by @${w.added_by})`
                ).join('\n');
              } else {
                message = '📋 No active watchers';
              }
            }
            
            // Save config
            if (command === 'watch' || command === 'unwatch') {
              await fs.writeFile(configPath, yaml.dump(config));
              
              // Commit changes
              const { execSync } = require('child_process');
              execSync(`git config user.name "github-actions[bot]"`);
              execSync(`git config user.email "github-actions[bot]@users.noreply.github.com"`);
              execSync(`git add ${configPath}`);
              execSync(`git commit -m "Update agentwatch config: ${command} ${agent} ${pattern}"`);
              execSync(`git push`);
            }
            
            // Post response
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: message
            });

  check-watchers:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    outputs:
      has_matches: ${{ steps.check.outputs.has_matches }}
      matched_agents: ${{ steps.check.outputs.matched_agents }}
    steps:
      - uses: actions/checkout@v4
      - name: Check Watchers
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs').promises;
            const yaml = require('js-yaml');
            const minimatch = require('minimatch');
            
            // Get changed files
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            const changedFiles = files.map(f => f.filename);
            
            // Load config
            let config = { watchers: [] };
            try {
              const content = await fs.readFile('.github/agentwatch.yml', 'utf8');
              config = yaml.load(content) || { watchers: [] };
            } catch (e) {
              // No config file
            }
            
            // Find matching watchers
            const matchedAgents = [];
            for (const watcher of config.watchers) {
              const matched = changedFiles.some(file => {
                if (!minimatch(file, watcher.pattern)) return false;
                for (const exclude of watcher.exclude || []) {
                  if (minimatch(file, exclude)) return false;
                }
                return true;
              });
              
              if (matched) {
                matchedAgents.push(watcher.agent);
              }
            }
            
            core.setOutput('has_matches', matchedAgents.length > 0);
            core.setOutput('matched_agents', matchedAgents.join(','));

  run-agents:
    needs: check-watchers
    if: needs.check-watchers.outputs.has_matches == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        agent: ${{ fromJson(needs.check-watchers.outputs.matched_agents) }}
    steps:
      - name: Add Pending Label
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              labels: [`agent:pending:${{ matrix.agent }}`]
            });
      
      - name: Update to Running Label
        uses: actions/github-script@v7
        with:
          script: |
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                name: `agent:pending:${{ matrix.agent }}`
              });
            } catch (e) {}
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              labels: [`agent:running:${{ matrix.agent }}`]
            });
      
      - name: Run Agent
        uses: ./.github/workflows/agent-${{ matrix.agent }}.yml
        
      - name: Update to Reviewed Label
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                name: `agent:running:${{ matrix.agent }}`
              });
            } catch (e) {}
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              labels: [`agent:reviewed:${{ matrix.agent }}`]
            });